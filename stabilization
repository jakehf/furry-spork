//Jacob Hanson-Flores

#include <Wire.h>
#include "Adafruit_Sensor.h"
#include "Adafruit_BNO055.h"
#include "utility/imumaths.h"
#include "Servo.h"
#include <Time.h>
#include <TimeLib.h>

Adafruit_BNO055 bno = Adafruit_BNO055(55);
//sensors_event_t event;
Servo MyServo;  //First Motor
Servo MyServo2; //Second Motor
int LeftLED = 13; //First LED
int RightLED = 12; //Second LED
int MiddleLED = 11; //Middle LED

void setup(void) 
{  

  Serial.begin(9600);
  Serial.println("Orientation Sensor Test"); Serial.println("");
  MyServo.attach(9);
  MyServo2.attach(6);
  pinMode(LeftLED, OUTPUT);
  /* Initialise the sensor */
  if(!bno.begin())
  {
    /* There was a problem detecting the BNO055 ... check your connections */
    Serial.print("Ooops, no BNO055 detected ... Check your wiring or I2C ADDR!");
    while(1);
  }
  
  delay(1000);
    
  bno.setExtCrystalUse(true);
}


float delta (float x1, float x2) //Fairly simple function, takes in 2 positions and calculates the difference
{ 
  printf("made it");
  float a = x1;
  float b = x2;
  float delt = a-b;
  return delt;
}

void reset() //This function tells our servos to return the flaps back to their original position.
{
  MyServo.write(90);
  MyServo2.write(90);
}

void douknowzeway(float z) //This function will be used to tell our servos which direction to turn
                            //based on the direction of our thetavector
  {
    float l; //sets up a float which will represent the theta vector
    l = z;  //Sets l to the theta vector which was the argument for our function
    if(l >= 0) // If the theta vector is a positive value turn the servos to 105 degrees. (Need to determine if this should be
                //105 degrees or 75 degrees depending on which way the flaps should turn.
      {
        MyServo.write(105);
        MyServo2.write(105);
      }
    else //If the theta vector, l, is a negative value turn the flaps 15 degrees in the opposite direction
    {
      MyServo.write(75);
      MyServo2.write(75);
    }
    reset(); //After turning the flaps immediately resets the flaps to their original orientation
  }

void whereweat(float airay, float airaze) //takes in a pointer to an array which has the positions we are hoping to hold
{
  /* Get a new sensor event */ 
  sensors_event_t event;
  sensors_event_t orientation;
  bno.getEvent(&event); //Gets x,y, an z positions
  int x = event.orientation.x; //sets x = position in x
  
  float theta, dtheta; //declares these variables as floats
  time_t t0 = now(); //Taken from time library. https://github.com/PaulStoffregen/Time
  time_t t = now()-t0; //Sets the variable t as differnce in time
    do{
      theta = event.orientation.x; //sets theta to our current position
      dtheta = pow((airay-theta),2); //sets dtheta to the difference between the position we want to be at, and our current x,
                                          //then squares the value so its always positive
      if(dtheta > 225)
        {
          float thetavector = event.orientation.x; //gets the angular vector to use in our douknowzeway function
          douknowzeway(thetavector); //Feeds the current theta vector to our function. 
          //Which then turns the servos in the appropriate direction
        }
        t = now() - t0; //Sets our time = current time - time when function was called
    }while(t <= time);
    break;   //After t > time for stabilization breaks.
}

 
void loop(void) 
{
  int i,j;
  float positions[4] = {180, 90, 270, 0}; // Positions needed to go to
  float times[4] = {1.0, 0.75, 0.50, 0.25}; // Durations needed 1 second cycles through all 4 positions then 0.75 second .... 
  
  //size = Insert the number of commands that are located in array where we are reading in positions
  for(j=0; j<4; j++)
  {
    for(i=0; i<4; i++)
      {
        whereweat(positions[i], times[j]); //Runs the stabilization for the position located at array[i]
        //rollcontrol(array[i++]); //Runs the roll control to the next location in array
        float yvec = event.vector.y; //Sets the yvec = the current vertical velocity
        if(yvec <= 0) //If the yvec falls below 0 then we have started to descend and the roll control is no longer necessary;
          {
            break; //Code stops
          }
      }
  }
}
